# Agents Code Instructions for Opper Agent TS SDK

## Context

You are maintaining the TypeScript SDK for Opper Agents. This SDK provides strongly-typed, production-ready agent orchestration with full Opper platform integration, comprehensive tooling support, and idiomatic TypeScript patterns.

## Key Documents

- `SPEC.md` – canonical architecture, behaviours, and design specifications
- `opper-node.mdc` – Opper platform contract, tracing, and API expectations

Always cross-check these references before making architectural or behavioural changes.

## Code Quality Standards

### Architecture

- **Class contract**: `BaseAgent<Input, Output>` (abstract) with generics; concrete agents (e.g., `Agent`, `ReactAgent`, `ChatAgent`) extend or compose it.
- **Schemas**: Use `zod` for runtime validation and serialization parity with Python’s Pydantic models.
- **Async-first**: All agent operations remain async/await; support `AbortSignal` where cancellation makes sense.
- **Separation of concerns**: Keep methods small and focused; prefer composition over deep inheritance.

### Opper Integration

- Wrap the official Opper TypeScript client inside `src/opper/`.
- Every LLM call: `await opperClient.call({...})` with structured payloads.
- Emit spans via helper utilities (`createSpan`, `withChildSpan`) and propagate `parentSpanId`.
- Track usage on the `AgentContext` (`context.updateUsage(usage)`).
- Honour `outputSchema`/`inputSchema` contracts with `zod` definitions.

### Hook System

- Maintain lifecycle parity with Python (`HookEvents` union).
- Hooks are resolved through a `HookManager` that supports sync + async handlers.
- Guard hook execution with try/catch; log warnings via the shared logger.

### Error Handling

- Agent loop: enforce max iteration safeguards; bubble actionable errors.
- Tool invocation: return discriminated `ToolResult` union (`{ success: false, error }`) instead of throwing.
- Hook failures: log + continue.
- Memory failures: degrade gracefully, never break agent execution.

## Development Workflow

### Environment Setup

This project uses **pnpm**, `tsup`, and `vitest`.

```bash
pnpm install
pnpm lint
pnpm format
pnpm test
pnpm build
```

Use `pnpm prepare`/`pnpm prepublishOnly` hooks to run lint, tests, and build before publishing.

### Workflow

1. Implement or update code under `src/` (TypeScript SDK sources).
2. Add/update tests (`vitest`) alongside changes.
3. Run `pnpm test` (or `pnpm test:coverage` when required).
4. Format with `pnpm format` (Prettier) and lint with `pnpm lint` (ESLint + TS rules).
5. Verify `pnpm build` (tsup) succeeds before opening a PR.

### Opper Integration Testing Strategy

**Three-tier approach for Opper client tests:**

1. **Unit tests** (always run): Mocked `opper.call` with `vi.fn()` - fast, no API key needed.
2. **Fixture-based integration tests** (always run): Use saved real API responses from `tests/fixtures/opper/`. Verify parsing logic against actual Opper response structures. Run with `pnpm test:integration`.
3. **Live integration tests** (manual/pre-release only): Make real API calls. Skipped by default, only run with `OPPER_API_KEY=xxx pnpm test:integration:live` to verify SDK works with current Opper API or regenerate fixtures.

**Commands:**

- `pnpm fixtures:generate` - Regenerate fixtures from real Opper API (requires `OPPER_HTTP_BEARER`)
- `pnpm test:integration` - Run fixture-based integration tests (no API key)
- `pnpm test:integration:live` - Run live API tests (requires `OPPER_API_KEY`)

## Testing Rules (Critical)

Run unit tests from the repository root:

```bash
pnpm test
```

Use watch mode when iterating locally:

```bash
pnpm test:watch
```

### ❌ NEVER

- Remove or downgrade tests without explicit approval.
- Silence failures by loosening schemas or suppressing TypeScript errors.
- Skip formatting/lint steps before committing.
- Commit autogenerated build artifacts unless preparing a release bundle.

### ✅ ALWAYS

- Place tests under `tests/unit`, `tests/integration`, or `tests/e2e` as appropriate.
- Mock Opper/HTTP interactions with `msw`, manual stubs, or dependency injection; no real network calls in unit/integration tests.
- Use `vitest` utilities (`vi.fn`, `vi.mock`) for spies/mocks.
- Assert on structured results (`ToolResult`, `AgentContext`) rather than side effects when possible.

### Test Layout

```
tests/
├── unit/
├── integration/
└── e2e/
```

### Testing Patterns

**Unit Test Example**

```ts
import { describe, expect, it } from "vitest";
import { AgentContext } from "@/base/context";

describe("AgentContext usage tracking", () => {
  it("accumulates usage metrics", () => {
    const ctx = new AgentContext({ agentName: "Test" });
    ctx.updateUsage({ requests: 1, totalTokens: 100 });
    expect(ctx.usage.requests).toBe(1);
  });
});
```

**Integration Test Example**

```ts
import { describe, expect, it, vi } from "vitest";
import { Agent } from "@/core/agent";
import { mockOpperClient } from "../mocks/opper";

describe("Agent with mocked Opper", () => {
  it("returns a result and records a span", async () => {
    const opper = mockOpperClient({
      call: vi.fn().mockResolvedValue({ output: { text: "ok" }, usage: {} }),
    });

    const agent = new Agent({
      name: "Test",
      opperClient: opper,
      tools: [],
    });

    const result = await agent.process("hello");
    expect(result).toBeDefined();
    expect(opper.call).toHaveBeenCalled();
  });
});
```

## Common Patterns

### Tool Definition

```ts
import { Tool, ToolResult } from "@/base/tool";

export const searchTool: Tool<{ query: string }, { results: string[] }> = {
  name: "search_web",
  schema: z.object({ query: z.string().min(1) }),
  async execute({ query }) {
    // custom logic here
    return ToolResult.success({ results: [`Found: ${query}`] });
  },
};
```

### Hook Definition

```ts
import { HookManager } from "@/base/hooks";

hooks.on("agent:start", async ({ agent, context }) => {
  logger.debug(`Starting agent ${agent.name}`, { traceId: context.traceId });
});
```

### Agent Construction

```ts
const agent = new Agent({
  name: "ResearchAgent",
  description: "Researches topics and cites sources",
  instructions: "Be thorough and cite reputable references.",
  tools: [searchTool, summarizeTool],
  inputSchema: ResearchRequestSchema,
  outputSchema: ResearchResultSchema,
  maxIterations: 25,
  enableMemory: true,
});
```

### Opper Call Pattern

```ts
const span = spans.startChild("think", { parentId: context.traceId });

const response = await opperClient.call({
  name: "think",
  instructions: "Analyze and decide next action",
  input: inputSchema.parse(payload),
  outputSchema,
  model,
  spanId: span.id,
});

context.updateUsage(response.usage);
spans.finish(span);
```

## File Organization

```
opperai-agent-sdk-node/
├── src/
│   ├── index.ts
│   ├── base/
│   ├── core/
│   ├── agents/
│   ├── memory/
│   ├── mcp/
│   └── utils/
├── tests/
│   └── unit/
├── examples/
├── eslint.config.js
├── tsconfig.json
├── tsconfig.base.json
├── tsup.config.ts
├── vitest.config.ts
└── package.json
```

Keep barrel files (`index.ts`) curated; export only the public API surface.

## Questions to Ask Before Implementing

- Does this honour the `BaseAgent` generic contract and TypeScript typing guarantees?
- Are schemas (`zod`) defining both compile-time and runtime expectations?
- Are Opper spans, usage tracking, and errors surfaced consistently?
- Can custom agents/tools/memory backends extend this without hacks?
- Have we updated or added tests to cover new behaviour?
- Does this maintain compatibility with the Python SDK where applicable?

## Priority Order

1. **Correctness** – reliable behaviour and consistent Opper platform integration.
2. **Type Safety** – strong types, helpful errors, strict TypeScript config.
3. **Extensibility** – easy to extend agents, tools, memory, and MCP integrations.
4. **Performance** – optimize when profiling shows measurable regressions.

## Code Style

- Strict TypeScript (`strict`, `noUncheckedIndexedAccess`, `exactOptionalPropertyTypes`).
- Prefer readonly fields and discriminated unions for predictable control flow.
- Use ESLint (`@typescript-eslint`) and Prettier; no manual formatting deviations.
- Document public APIs with JSDoc/typedoc-compatible comments.
- Avoid default exports except in entry points; favour named exports for tree-shaking.
- No emojis unless explicitly requested.

## Success Criteria

- `pnpm lint`, `pnpm format`, `pnpm test`, and `pnpm build` all succeed
- Public API maintains strong type safety with proper generics
- Tests cover new behaviour with appropriate mocking strategies
- Documentation updated for any API changes (README, examples)
